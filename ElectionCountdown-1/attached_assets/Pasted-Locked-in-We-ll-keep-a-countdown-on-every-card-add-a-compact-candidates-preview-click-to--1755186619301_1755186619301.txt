Locked in. We’ll keep a **countdown on every card**, add a **compact candidates preview** (click to expand), and a **Compare** flow that opens a rich **Election Detail** + **Candidate Compare** view—backed by clean DB + API routes.

Below is copy-paste code you can drop into Replit. I’ve kept it tight and aligned with your stack (React TS + shadcn/ui + TanStack Query, Node/Express, Drizzle + Neon).

---

# 1) DB & Drizzle (joins + indexes)

```ts
// server/db/schema/candidates.ts
import { pgTable, varchar, integer, boolean, timestamp, index, primaryKey } from "drizzle-orm/pg-core";

export const elections = pgTable("elections", {
  id: varchar("id", { length: 36 }).primaryKey(),
  title: varchar("title", { length: 256 }).notNull(),
  date: timestamp("date", { withTimezone: true }).notNull(),
  state: varchar("state", { length: 2 }),
  level: varchar("level", { length: 16 }),    // federal|state|local
  type: varchar("type", { length: 16 })       // general|primary|runoff|special
}, (t) => ({
  byDate: index("elections_by_date").on(t.date),
  byState: index("elections_by_state").on(t.state),
}));

export const candidates = pgTable("candidates", {
  id: varchar("id", { length: 36 }).primaryKey(),
  name: varchar("name", { length: 160 }).notNull(),
  party: varchar("party", { length: 32 }),
  state: varchar("state", { length: 2 }),
  office: varchar("office", { length: 64 }),
  incumbent: boolean("incumbent").default(false),
  fecId: varchar("fec_id", { length: 32 }),
  photoUrl: varchar("photo_url", { length: 512 }),
  searchText: varchar("search_text", { length: 1024 }), // for FTS
}, (t) => ({
  byState: index("candidates_by_state").on(t.state),
  byParty: index("candidates_by_party").on(t.party)
}));

export const candidateElections = pgTable("candidate_elections", {
  electionId: varchar("election_id", { length: 36 }).notNull(),
  candidateId: varchar("candidate_id", { length: 36 }).notNull(),
  status: varchar("status", { length: 16 }).default("qualified"), // qualified|withdrawn
  ballotPosition: integer("ballot_position"),
}, (t) => ({
  pk: primaryKey({ columns: [t.electionId, t.candidateId] }),
  byElection: index("cand_elec_by_election").on(t.electionId),
  byCandidate: index("cand_elec_by_candidate").on(t.candidateId),
}));
```

> Migration: create table if missing; add indexes above. (Matches your current tables and adds the join table if you don’t already have it.)

---

# 2) API routes (Express + Drizzle)

```ts
// server/routes/elections.ts
import { Router } from "express";
import { db } from "../db";
import { elections, candidates, candidateElections } from "../db/schema/candidates";
import { and, eq, inArray } from "drizzle-orm";

export const electionsRouter = Router();

// GET /api/elections/:id (basic election + candidate count)
electionsRouter.get("/:id", async (req, res) => {
  const { id } = req.params;
  const [e] = await db.select().from(elections).where(eq(elections.id, id)).limit(1);
  if (!e) return res.status(404).json({ error: "Not found" });

  const [{ count }] = await db
    .select({ count: db.fn.count(candidateElections.candidateId) })
    .from(candidateElections)
    .where(eq(candidateElections.electionId, id));

  res.json({ ...e, candidates: Number(count) });
});

// GET /api/elections/:id/candidates – lightweight names list for the card dropdown
electionsRouter.get("/:id/candidates", async (req, res) => {
  const { id } = req.params;
  const rows = await db
    .select({
      id: candidates.id, name: candidates.name, party: candidates.party,
      incumbent: candidates.incumbent
    })
    .from(candidateElections)
    .innerJoin(candidates, eq(candidateElections.candidateId, candidates.id))
    .where(eq(candidateElections.electionId, id))
    .orderBy(candidateElections.ballotPosition);
  res.json(rows);
});

// GET /api/candidates?ids=a,b,c – full profiles for Compare page
electionsRouter.get("/candidates-by-ids", async (req, res) => {
  const ids = String(req.query.ids ?? "").split(",").filter(Boolean);
  if (!ids.length) return res.json([]);
  const rows = await db.select().from(candidates).where(inArray(candidates.id, ids));
  res.json(rows);
});

// Optionally aggregate /api/compare?ids=… to include finance/polling if keys exist.
```

*Register the router:*

```ts
// server/index.ts
import { electionsRouter } from "./routes/elections";
app.use("/api/elections", electionsRouter);
```

---

# 3) Frontend — candidates preview + compare basket

### 3.1 Compare basket (URL + localStorage)

```tsx
// client/src/compare/CompareContext.tsx
import React, { createContext, useContext, useMemo } from "react";
import { useLocalStorage } from "@/hooks/useLocalStorage";

type Ctx = { selected: string[]; toggle: (id: string)=>void; clear: ()=>void; };
const C = createContext<Ctx>({ selected: [], toggle: ()=>{}, clear: ()=>{} });
export const useCompare = () => useContext(C);

export function CompareProvider({ children }: { children: React.ReactNode }) {
  const [selected, setSelected] = useLocalStorage<string[]>("compare:candidates", []);

  const api = useMemo<Ctx>(() => ({
    selected,
    toggle: (id) =>
      setSelected((prev) => prev.includes(id) ? prev.filter(x=>x!==id) : [...prev, id].slice(-5)),
    clear: () => setSelected([]),
  }), [selected, setSelected]);

  return <C.Provider value={api}>{children}</C.Provider>;
}
```

*Wrap your app once (App.tsx or main.tsx):*

```tsx
<CompareProvider>
  <App />
</CompareProvider>
```

### 3.2 Candidates preview (lazy fetch on expand, selectable)

```tsx
// client/src/components/CandidatesPreview.tsx
import { useState } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useCompare } from "@/compare/CompareContext";
import { titleCase } from "@/utils/tags";

async function fetchCandidates(electionId: string) {
  const r = await fetch(`/api/elections/${electionId}/candidates`);
  if (!r.ok) throw new Error("fetch candidates failed");
  return r.json() as Promise<{id:string;name:string;party?:string;incumbent?:boolean}[]>;
}

export default function CandidatesPreview({ electionId, count }: { electionId: string; count?: number }) {
  const qc = useQueryClient();
  const [open, setOpen] = useState(false);
  const { selected, toggle } = useCompare();

  const q = useQuery({
    queryKey: ["election", electionId, "candidates"],
    queryFn: () => fetchCandidates(electionId),
    enabled: open
  });

  // Prefetch on hover/focus
  const prefetch = () => qc.prefetchQuery({ queryKey: ["election", electionId, "candidates"], queryFn: () => fetchCandidates(electionId) });

  return (
    <div className="mt-2">
      <button
        onClick={() => setOpen(v=>!v)}
        onMouseEnter={prefetch}
        className="text-xs px-2 py-1 rounded-lg border hover:bg-muted"
        aria-expanded={open}
      >
        {open ? "Hide" : "Candidates"}{typeof count === "number" ? ` (${count})` : ""}
      </button>

      {open && (
        <div className="mt-2 border rounded-xl p-2 space-y-1">
          {q.isLoading && <div className="text-xs text-muted-foreground">Loading…</div>}
          {q.data?.map(c => {
            const checked = selected.includes(c.id);
            return (
              <label key={c.id} className="flex items-center justify-between text-sm gap-3">
                <div className="truncate">
                  <span className="font-medium">{c.name}</span>
                  {c.party && <span className="ml-2 text-xs text-muted-foreground">{titleCase(c.party)}</span>}
                  {c.incumbent && <span className="ml-2 text-[11px] px-1 rounded bg-amber-50 text-amber-800">Incumbent</span>}
                </div>
                <input
                  type="checkbox"
                  checked={checked}
                  onChange={() => toggle(c.id)}
                  aria-label={`Add ${c.name} to compare`}
                />
              </label>
            );
          })}
          {!!selected.length && (
            <a
              href={`/compare?c=${selected.join(",")}`}
              className="mt-2 inline-flex text-xs px-3 py-1.5 rounded-lg border bg-background hover:bg-muted"
            >
              Compare ({selected.length})
            </a>
          )}
        </div>
      )}
    </div>
  );
}
```

### 3.3 Drop it into the card

```tsx
// client/src/components/ElectionCard.tsx (add under chips, before Actions)
import CandidatesPreview from "@/components/CandidatesPreview";

// ...
<CandidatesPreview electionId={e.id} count={e.candidates} />
```

---

# 4) Election Detail page (rich view)

```tsx
// client/src/pages/ElectionDetail.tsx
import { useParams } from "wouter";
import { useQuery } from "@tanstack/react-query";
import Countdown from "@/components/Countdown";
import { formatDateLocal } from "@/utils/date";
import CandidatesPreview from "@/components/CandidatesPreview";

async function fetchElection(id: string) {
  const r = await fetch(`/api/elections/${id}`);
  if (!r.ok) throw new Error("not found");
  return r.json();
}

export default function ElectionDetail() {
  const { id = "" } = useParams<{ id: string }>();
  const { data: e, isLoading } = useQuery({ queryKey: ["election", id], queryFn: () => fetchElection(id) });

  if (isLoading) return <div className="p-6 text-sm">Loading…</div>;
  if (!e) return <div className="p-6 text-sm">Election not found.</div>;

  return (
    <div className="p-6 space-y-6">
      <header className="flex items-start justify-between">
        <div>
          <h1 className="text-xl font-bold">{e.title}</h1>
          <div className="text-sm text-muted-foreground">
            {formatDateLocal(e.date)} · {e.state ?? "US"} · {e.level} · {e.type}
          </div>
        </div>
        <Countdown when={e.date} />
      </header>

      <section className="space-y-2">
        <h2 className="text-base font-semibold">Candidates</h2>
        <CandidatesPreview electionId={e.id} count={e.candidates} />
      </section>

      <section className="grid md:grid-cols-2 gap-4">
        <div className="rounded-xl border p-4">
          <h3 className="text-sm font-semibold mb-2">Polling Trends</h3>
          <div className="text-xs text-muted-foreground">Connect OpenFEC/OpenStates/VoteSmart to enable charts.</div>
        </div>
        <div className="rounded-xl border p-4">
          <h3 className="text-sm font-semibold mb-2">Finance Summary</h3>
          <div className="text-xs text-muted-foreground">FEC data appears here when API key is present.</div>
        </div>
      </section>
    </div>
  );
}
```

*Add route (Wouter):*

```tsx
// client/src/App.tsx
<Route path="/elections/:id" component={ElectionDetail} />
```

---

# 5) Compare page (head-to-head)

```tsx
// client/src/pages/Compare.tsx
import { useLocation } from "wouter";
import { useQuery } from "@tanstack/react-query";
import { titleCase } from "@/utils/tags";

function useIdsFromQuery() {
  const [loc] = useLocation();
  const params = new URLSearchParams(loc.split("?")[1] ?? "");
  return (params.get("c") ?? "").split(",").filter(Boolean);
}

export default function ComparePage() {
  const ids = useIdsFromQuery();
  const { data = [] } = useQuery({
    queryKey: ["candidates", ids],
    queryFn: async () => {
      if (!ids.length) return [];
      const r = await fetch(`/api/elections/candidates-by-ids?ids=${ids.join(",")}`);
      if (!r.ok) throw new Error("fetch candidates failed");
      return r.json();
    }
  });

  if (!ids.length) return <div className="p-6 text-sm">Select two or more candidates to compare.</div>;

  return (
    <div className="p-6">
      <h1 className="text-xl font-bold mb-4">Candidate Comparison</h1>
      <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
        {data.map((c: any) => (
          <div key={c.id} className="rounded-xl border p-4 space-y-2">
            <div className="flex items-center gap-3">
              {c.photoUrl && <img src={c.photoUrl} className="w-10 h-10 rounded-full object-cover" alt="" />}
              <div>
                <div className="font-semibold">{c.name}</div>
                <div className="text-xs text-muted-foreground">{titleCase(c.party)} · {c.state}</div>
              </div>
            </div>
            <div className="text-xs">
              <div>Office: {c.office ?? "—"}</div>
              <div>Incumbent: {c.incumbent ? "Yes" : "No"}</div>
              {/* placeholders for finance/polling when keys present */}
              <div className="mt-2 text-muted-foreground">Finance/Polling appear when API keys are configured.</div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

*Add route:*

```tsx
<Route path="/compare" component={ComparePage} />
```

---

# 6) Update card CTA to open details (and keep Compare in preview)

```tsx
// client/src/components/ElectionCard.tsx (Actions)
<a href={`/elections/${e.id}`} className="inline-flex items-center justify-center text-xs h-8 px-3 rounded-lg border bg-background hover:bg-muted">
  Details
</a>
```

---

# 7) Minimal tests (RTL)

```ts
// client/src/components/__tests__/CandidatesPreview.test.tsx
import { render, screen } from "@testing-library/react";
import CandidatesPreview from "@/components/CandidatesPreview";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { CompareProvider } from "@/compare/CompareContext";

test("renders Candidates button", () => {
  const qc = new QueryClient();
  render(
    <QueryClientProvider client={qc}>
      <CompareProvider>
        <CandidatesPreview electionId="x1" count={3} />
      </CompareProvider>
    </QueryClientProvider>
  );
  expect(screen.getByRole("button", { name: /candidates/i })).toBeInTheDocument();
});
```

---

## Targeted questions for Replit (reply here so I can wire it perfectly)

1. **Data shape**: Do you already have a `candidate_elections` join table? If yes, what are the exact column names?
2. **IDs**: Are `elections.id` and `candidates.id` UUID strings as in code, or numeric?
3. **Photos**: Do you store `photo_url` or should I derive images (e.g., from bioguide/FEC) when available?
4. **Finance/Polling**: Which keys are currently set (OpenFEC, OpenStates, VoteSmart)? I’ll enable those sections conditionally.
5. **Existing endpoints**: If you already have routes for `/api/elections/:id` and `/api/elections/:id/candidates`, tell me their response shape and I’ll adapt instead of adding new ones.
6. **Virtualization**: Are we keeping `react-virtuoso` grid? If you plan to switch to list view sometimes, I’ll add dynamic height handling for expanded candidate lists.

Answer those and I’ll tune the code to your exact tables/routes (no guesswork).

---

### Acceptance (what “done” looks like)

* Each election card shows **Candidates (N)**; clicking reveals a **selectable list** (lazy-fetched).
* Users can **tick 2–5** names and hit **Compare** to open `/compare?c=…`.
* Clicking **Details** opens `/elections/:id` with countdown, meta, candidates, and stubs for polling/finance that auto-activate when keys exist.
* No layout jitter; virtualization remains smooth; a11y clean (labels, focus, tabular digits).

If you want, I can produce a **unified patch** that drops all files/changes in one go.
