Short answer: those “empty” cards are loading correctly—the API is returning **no candidates for that election ID**, so the UI shows the skeleton bar. The AD-63 card works because those candidates exist in your DB and are linked to that election. The Los Banos card (and others like it) don’t, even though candidates exist in the wild. That’s a **data linkage gap** (missing/incorrect `candidates.election_id` or no rows), not a countdown/virtualization issue.

Below is a tight, copy-paste fix set that (a) proves the problem, (b) patches the UI so it never looks “stuck”, and (c) reconciles/backfills candidates for the two Aug-26 races and gives you a repeatable pattern for other locals.

---

## 0) Prove it (run in SQL console)

```sql
-- Find the two Aug 26, 2025 CA elections
select id, title, state, date, level
from elections
where state='CA' and date='2025-08-25'
  and (title ilike '%Los Banos%' or title ilike '%Assembly District 63%');

-- Check linked candidates for each ID
-- (replace :ID with the id from the first query)
select id, full_name, party, incumbent, election_id
from candidates
where election_id = :ID
order by full_name;

-- Cross-check by names you know should be present (should return 0 rows today for Los Banos)
select id, full_name, party, election_id
from candidates
where lower(full_name) in ('mitzy perez','kalid sanchez','virriy kalid sanchez');
```

You’ll see AD-63 has rows; Los Banos has none. That’s why the left card shows a blank/skeleton.

---

## 1) Quick UI patch (no more “stuck” skeleton)

**client/src/components/ElectionCard.tsx** – make empty/error states explicit and cancellable.

```tsx
// inside the candidate drawer content:
{loading && <div className="h-2 rounded bg-muted animate-pulse" aria-live="polite" />}
{error && (
  <div className="text-amber-600 text-sm">
    Couldn’t load candidates ({error}). <button className="underline" onClick={reload}>Retry</button>
  </div>
)}
{!loading && !error && candidates.length === 0 && (
  <div className="text-sm text-muted-foreground">
    No verified candidates recorded yet.
    <button className="ml-2 underline" onClick={reload}>Check again</button>
  </div>
)}
```

And ensure the fetch is properly aborted on unmount (virtualization safe):

```tsx
useEffect(() => {
  if (!open) return;
  const ac = new AbortController();
  setLoading(true); setError(null);
  fetch(`/api/elections/${election.id}/candidates`, { signal: ac.signal })
    .then(r => r.ok ? r.json() : Promise.reject(r.status))
    .then(setCandidates)
    .catch(err => { if (err.name !== 'AbortError') setError(String(err)); })
    .finally(() => setLoading(false));
  return () => ac.abort();
}, [open, election.id]);
```

---

## 2) API “intelligent fallback” (same DB, no mocks)

If the direct link returns zero, try a similarity match on same **state+date** and title using `pg_trgm`. This catches cases where candidates were ingested under a duplicated title/ID.

**server/routes/elections.ts**

```ts
router.get('/:id/candidates', async (req, res, next) => {
  const id = Number(req.params.id);
  if (!Number.isFinite(id)) return res.status(400).json({ error: 'bad id' });

  const { rows: direct } = await pool.query(
    `select id, full_name, party, incumbent, profile_image_url
     from candidates where election_id=$1 order by full_name`, [id]);
  if (direct.length) return res.json(direct);

  // Fallback: same state & date, similar title (pg_trgm)
  const { rows: [e] } = await pool.query(
    `select id, title, state, date, coalesce(level,'') as level from elections where id=$1`, [id]);
  if (!e) return res.status(404).json({ error: 'election not found' });

  const { rows: fuzzy } = await pool.query(
    `select c.id, c.full_name, c.party, c.incumbent, c.profile_image_url
       from candidates c
       join elections ex on ex.id = c.election_id
      where ex.state = $1 and ex.date = $2 and similarity(ex.title, $3) > 0.63
      order by c.full_name`,
    [e.state, e.date, e.title]
  );

  return res.json(fuzzy); // empty array if truly none
});
```

> Requires `pg_trgm`. Enable if needed:

```sql
create extension if not exists pg_trgm;
```

---

## 3) Backfill the two Aug-26 races (authoritative, with source URLs)

> This is **not mock data**—we store provenance in `source_url`. Add a uniqueness guard so re-runs are safe.

```sql
-- 3a) Safety: uniqueness on (election_id, lower(full_name))
do $$
begin
  if not exists (
    select 1 from pg_indexes where indexname = 'uniq_candidates_eid_name'
  ) then
    execute 'create unique index uniq_candidates_eid_name
             on candidates (election_id, lower(full_name))';
  end if;
end $$;

-- 3b) Get the IDs you saw in step 0
-- suppose they are:
--   :AD63_ID and :LB_ID  (replace below)

-- 3c) AD-63 already present for you; skip unless missing
insert into candidates (election_id, full_name, party, incumbent, profile_image_url, source_url)
values
  (:AD63_ID, 'Chris Shoults', 'Democratic', false, null, 'https://www.sos.ca.gov/elections/upcoming-elections/2025-ad63'),
  (:AD63_ID, 'Natasha Johnson', 'Republican', false, null, 'https://www.sos.ca.gov/elections/upcoming-elections/2025-ad63')
on conflict on constraint uniq_candidates_eid_name do nothing;

-- 3d) Los Banos City Council D1 (local special)
insert into candidates (election_id, full_name, party, incumbent, profile_image_url, source_url)
values
  (:LB_ID, 'Mitzy Perez', 'Nonpartisan', false, null, 'https://losbanos.org/wp-content/uploads/2025/07/Notice-of-Nominees-Aug-2025-mm.pdf'),
  (:LB_ID, 'Kalid "Virriy" Sanchez', 'Nonpartisan', false, null, 'https://losbanos.org/wp-content/uploads/2025/07/Notice-of-Nominees-Aug-2025-mm.pdf')
on conflict on constraint uniq_candidates_eid_name do nothing;

-- 3e) refresh counts view if you use one
-- e.g., REFRESH MATERIALIZED VIEW CONCURRENTLY v_election_candidate_counts;  (if materialized)
```

Now reload the page: the left card will render both names immediately.

---

## 4) Find every other “empty but should have candidates” race (one query)

```sql
-- Elections within 60 days that have zero linked candidates
-- but likely should (local/state/federal), sorted by imminence
select e.id, e.title, e.state, e.date, e.level
from elections e
left join v_election_candidate_counts v on v.election_id = e.id
where (v.candidate_count is null or v.candidate_count = 0)
  and e.date between now()::date - interval '7 days' and now()::date + interval '60 days'
order by e.date asc, e.state;

-- If you have a raw ingest table (e.g., staging_candidates) without election_id,
-- surface fuzzy matches to help link quickly:
with suspect as (
  select s.full_name, s.party, s.state, s.election_date, s.source_url, e.id as election_id, e.title,
         similarity(e.title, s.election_title) as sim
  from staging_candidates s
  join elections e on e.state = s.state and e.date = s.election_date
  where e.date >= now()::date - interval '90 days'
)
select * from suspect where sim > 0.63 order by election_date, sim desc;
```

This gives you a punch-list to link or import candidates fast.

---

## 5) Manus checks (guard rails so this doesn’t regress)

Add two E2E specs:

```ts
// tests/e2e/candidates.aug26.spec.ts
import { test, expect } from "@playwright/test";

const API = process.env.API_BASE!;

async function getElectionId(titlePart: string) {
  const list = await fetch(`${API}/api/elections?limit=2000`).then(r=>r.json());
  const hit = list.find((e: any) => (e.title as string).toLowerCase().includes(titlePart));
  if (!hit) throw new Error(`Election not found: ${titlePart}`);
  return hit.id;
}

test("AD-63 shows Shoults & Johnson", async () => {
  const id = await getElectionId("assembly district 63");
  const cs = await fetch(`${API}/api/elections/${id}/candidates`).then(r=>r.json());
  const names = cs.map((c: any)=>c.full_name.toLowerCase());
  expect(names).toContain("chris shoults");
  expect(names).toContain("natasha johnson");
});

test("Los Banos D1 shows Perez & Sanchez", async () => {
  const id = await getElectionId("los banos district 1");
  const cs = await fetch(`${API}/api/elections/${id}/candidates`).then(r=>r.json());
  const names = cs.map((c: any)=>c.full_name.toLowerCase());
  expect(names).toContain("mitzy perez");
  expect(names.some((n:string)=>n.includes("sanchez"))).toBeTruthy();
});
```

And a UI smoke to ensure no “perma-skeleton”:

```ts
// tests/e2e/ui.noStuckSkeleton.spec.ts
import { test, expect } from "@playwright/test";

test("candidate drawer never stays skeleton", async ({ page }) => {
  await page.goto(process.env.BASE_URL! + "/");
  await page.getByText(/Los Banos/i).getByRole("button", { name: /Candidates|Show/i }).click();
  await expect(page.getByText(/No verified candidates|Kalid|Mitzy/i)).toBeVisible({ timeout: 4000 });
});
```

---

## 6) Why this happened (so we can prevent it)

* Our ingestion currently **completes state/federal** (e.g., AD-63) but **doesn’t auto-cover many municipal specials** (Los Banos).
* The cards only show what’s in **our DB**; if `candidates` is empty (or mis-linked), the UI looks like a blank strip.
* Google Civic/OpenStates often don’t list small municipal specials; county/city PDFs are the authoritative sources (you already linked them). That requires either:

  * a one-time **seed/import** per known local special (with `source_url`), or
  * building **county scrapers** (more time) plus a review queue.

---

### TL;DR Fix sequence

1. Apply the **UI patch** (no more stuck skeletons).
2. Add the **API fallback** (pg\_trgm similarity on same state+date).
3. **Backfill** Los Banos candidates with the SQL provided (includes sources).
4. Run the **two Manus tests** so these never regress.
5. Use the “find missing candidates” SQL to knock out the rest in one pass (or wire up importers).

If you want, I can bundle these patches into a single diff the same way as FixPack v4 so you can drop it in one go.
